# LingChat 数据库开发文档

## 1. 数据库概览

*   **数据库类型**: SQLite3
*   **存储位置**: `user_data_path/chat_system.db` (通常位于项目根目录的 `data/` 下，或者系统用户数据目录)
*   **连接方式**: 使用 Python 原生 `sqlite3` 库，配置 `sqlite3.Row` 以支持字典方式访问列数据。
*   **核心特性**:
    *   强制开启外键约束 (`PRAGMA foreign_keys = ON`)。
    *   采用**关系链**方式存储消息历史（类似 Git 的提交链），而非简单的扁平列表。

---

## 2. 数据库模式 (Schema)

### 2.1 E-R 关系图概述
*   **Users** (1) -> (N) **Conversations**
*   **Characters** (1) -> (N) **Conversations**
*   **Conversations** (1) -> (N) **Messages**
*   **Messages** (1) -> (N) **MessageRelations** (自关联)

### 2.2 表结构定义

#### `users` (用户表)
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | INTEGER | PK, AI | 用户ID |
| `username` | TEXT | UNIQUE | 用户名 |
| `password` | TEXT | NOT NULL | 密码（目前代码中未加盐，直接存储） |
| `last_chat_character` | INTEGER | FK | 最后对话的角色ID，关联 `characters.id` |
| `created_at` | TIMESTAMP | DEFAULT CURRENT | 创建时间 |

#### `characters` (角色表)
*数据主要通过文件系统同步生成。*
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | INTEGER | PK, AI | 角色ID |
| `title` | TEXT | DEFAULT '默认' | 角色名称 |
| `resource_path` | TEXT | NOT NULL | 角色资源文件夹的绝对/相对路径 |

#### `conversations` (会话表)
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | INTEGER | PK, AI | 会话ID |
| `title` | TEXT | DEFAULT | 会话标题 |
| `last_message_id` | INTEGER | FK | **核心字段**：指向当前会话链条中最后一条消息的ID |
| `owned_user` | INTEGER | FK | 所属用户ID (级联删除) |
| `character` | INTEGER | FK | 关联角色ID (级联删除) |
| `updated_at` | TIMESTAMP | | 更新时间 |

#### `messages` (消息表)
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | INTEGER | PK, AI | 消息ID |
| `role` | TEXT | CHECK | 枚举值: `'system'`, `'user'`, `'assistant'` |
| `content` | TEXT | NOT NULL | 消息内容 |
| `owned_conversation`| INTEGER | FK | 所属会话ID (级联删除) |

#### `message_relations` (消息关系表)
*用于构建消息树/链结构。*
| 字段名 | 类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `parent_id` | INTEGER | FK | 父消息ID |
| `child_id` | INTEGER | FK | 子消息ID |
| **复合主键** | (parent, child) | | 确保关系唯一 |

---

## 3. 接口定义 (Model Layer)

所有数据库操作封装在 `database/` 目录下的 Model 类中。

### 3.1 基础连接 (`database.py`)
*   **`init_db()`**: 初始化数据库，创建所有表结构和索引。
*   **`get_db_connection()`**: 获取数据库连接对象，`row_factory` 已设置为 `sqlite3.Row`。

### 3.2 用户模型 (`user_model.py`)

**类: `UserModel`**
*   `create_user(username, password) -> int`: 创建用户，返回 ID。若用户名重复抛出 `ValueError`。
*   `get_user_by_id(user_id) -> dict`: 获取用户信息。
*   `update_user_character(user_id, character_id) -> bool`: 更新用户当前选中的角色。

**类: `UserConversationModel`**
*   `get_user_conversations(user_id, page, page_size) -> dict`: 分页获取用户的会话列表。
    *   返回结构: `{"conversations": [...], "total": int}`

### 3.3 角色模型 (`character_model.py`)

**类: `CharacterModel`**
*   `sync_characters_from_game_data(game_data_path) -> List[int]`: **核心方法**。扫描 `game_data/characters` 目录，读取 `settings.txt`，自动同步到数据库。
    *   新增文件 -> 插入数据库。
    *   修改标题 -> 更新数据库。
    *   文件删除 -> 删除数据库记录。
*   `get_all_characters() -> List[dict]`: 获取所有角色。
*   `get_character_settings_by_id(character_id) -> dict`: 不仅查询 DB，还会读取文件系统中的 `settings.txt` 并解析为字典。

### 3.4 会话与消息模型 (`conversation_model.py`)

**类: `ConversationModel`**
*   `create_conversation(user_id, messages, character_id, title) -> int`:
    *   创建一个新会话。
    *   **性能优化**: 使用 `PRAGMA synchronous = OFF` 和 `journal_mode = MEMORY` 进行批量插入。
    *   自动构建消息间的 `message_relations`。
*   `append_messages_to_conversation(conversation_id, messages)`:
    *   向现有会话追加消息。
    *   自动查找当前的 `last_message_id` 作为父节点，插入新消息并更新 `last_message_id`。
*   `change_conversation_messages(conversation_id, messages)`:
    *   **重置会话**：删除该会话下所有旧消息，批量插入新消息列表。常用于从内存/RAG回写完整历史。
*   `get_conversation_messages(conversation_id) -> str(JSON)`:
    *   **回溯算法**: 从 `conversations.last_message_id` 开始，通过 `message_relations` 表向上查找父节点，直到根节点。
    *   返回按时间正序排列的 JSON 字符串。

---

## 4. 开发注意事项 (Precautions)

### 4.1 消息链机制 (Message Chaining)
本项目不使用简单的 `SELECT * FROM messages WHERE conversation_id = ? ORDER BY id` 来获取历史记录。
*   **原理**: 采用链表结构 (`message_relations`)。
*   **原因**: 允许未来的功能扩展（如分支对话、重新生成回复而不覆盖原记录）。
*   **注意**:
    *   插入消息时必须维护 `message_relations`。
    *   必须更新 `conversations` 表中的 `last_message_id`，否则 `get_conversation_messages` 无法回溯到新消息。
    *   使用 `ConversationModel` 提供的方法操作，尽量不要手动直接操作 SQL 插入消息。

### 4.2 性能优化与事务
在 `ConversationModel` 的批量操作（如 `create_conversation` 和 `change_conversation_messages`）中，代码显式修改了 SQLite 的 PRAGMA 设置：
```python
conn.execute("PRAGMA synchronous = OFF")
conn.execute("PRAGMA journal_mode = MEMORY")
```
*   **风险**: 这极大地提高了写入速度（用于导入大量聊天记录），但如果系统在此时崩溃，可能会导致数据库损坏。
*   **最佳实践**: 仅在批量导入时使用此模式，且代码中已包含 `finally` 块将设置还原。

### 4.3 角色数据同步
角色数据是 **文件系统优先 (File-System First)** 的。
*   **流程**: 启动时或调用 API `refresh_characters` 时，会读取磁盘上的文件夹。
*   **注意**: 不要手动在数据库中 `INSERT` 角色，应该在磁盘创建文件夹和 `settings.txt`，然后调用同步方法。数据库中的 `resource_path` 是连接 DB 和文件的关键桥梁。

### 4.4 外键约束
*   SQLite 默认不开启外键，但本项目在 `init_db` 和 `get_db_connection` 中显式开启了：
    ```python
    cursor.execute("PRAGMA foreign_keys = ON")
    ```
*   **影响**:
    *   删除 `users` 会级联删除其下的 `conversations`。
    *   删除 `conversations` 会级联删除其下的 `messages`。
    *   删除 `messages` 会级联删除 `message_relations`。
*   **注意**: 在执行删除操作时，无需手动清理关联表数据，数据库会自动处理。

### 4.5 线程安全
*   SQLite 连接对象不能跨线程共享。`get_db_connection()` 必须在当前线程内调用，用完即关 (`conn.close()`)。
*   FastAPI 是异步的，但 `sqlite3` 库是同步阻塞的。在高并发场景下可能会阻塞事件循环。目前的实现适合单用户或少用户场景。

### 4.6 数据迁移
目前项目中没有引入 Alembic 或其他迁移工具。
*   `init_db()` 仅包含 `CREATE TABLE IF NOT EXISTS`。
*   **注意**: 如果修改了表结构（如添加字段），需要手动编写 SQL 修改现有数据库，或者删除 `chat_system.db` 重建（会导致数据丢失）。建议在后续开发中引入迁移机制。

## 5. 常用查询示例 (SQL)

**手动查询某会话的最后一条消息:**
```sql
SELECT m.content, m.role 
FROM conversations c
JOIN messages m ON c.last_message_id = m.id
WHERE c.id = 1;
```

**查询某条消息的父消息:**
```sql
SELECT parent.* 
FROM messages parent
JOIN message_relations rel ON parent.id = rel.parent_id
WHERE rel.child_id = {child_message_id};
```

**查询孤儿消息 (数据一致性检查):**
```sql
SELECT * FROM messages 
WHERE id NOT IN (SELECT child_id FROM message_relations) 
AND id NOT IN (SELECT id FROM messages WHERE id IN (SELECT MIN(id) FROM messages GROUP BY owned_conversation));
```